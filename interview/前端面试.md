- javascript面试
  - 类（伪）数组使用数组方法
  - 借用一道面试题（console.log())
  - 借用另一道面试题（console.log())
  - bind
- 如何面试前端工程师：GitHub 很重要
  - 第一部分：Object Prototypes (对象原型)
  - 第二部分：参数 arguments（同借用一道面试题、借用另一道面试题）
  - 第三部分：上下文
  - 第四部分：弹出窗口（Overlay library）

1. Value vs. Reference — Understand that objects, arrays, and functions are copied and passed by reference. Understand that primitives are copied and passed by value
2. Scope — Understand the difference between global scope, function scope, and block scope. Understand which variables are available where. Know how the JavaScript engine performs variable lookup.
3. Hoisting — Understand that variable and function declarations are hoisted to the top of their available scope. Understand that function expressions are not hoisted
Closures — Know that a function retains access to the scope that it was created in. Know what this lets us do, such as data hiding, memoization, and dynamic function generation
4. this — Know the rules of this binding. Know how it works, know how to figure out what it will be equal to in a function, and know why it’s useful
5. new — Know how it relates to object oriented programming. Know what happens to a function called with new. Understand how the object generated by using new inherits from the function’s prototype property
6. Prototypes & Inheritance — Understand that inheritance in JavaScript works through the [[Prototype]] chain. Understand how to set up inheritance through functions and objects and how new helps us implement it. Know what the `__proto__` and prototype properties are and what they do.
7. Asynchronous JS — Understand the event loop. Understand how the browser deals with user input, web requests, and events in general. Know how to recognize and correctly implement asynchronous code. Understand how JavaScript is both asynchronous and single-threaded.
8. Higher Order Functions — Understand that functions are first-class objects in JavaScript and what that means. Know that returning a function from another function is perfectly legal. Understand the techniques that closures and higher order functions allow us to use.
9. [apply, call, bind](https://codeplanet.io/javascript-apply-vs-call-vs-bind/) 

| Method     |     |  note |
| :------------- | :------------- |:------------- |
| **Call** | invokes the function and allows you to pass in arguments one by one| Apply is for Array, `func.call(this, arg1, arg2);`|
| **Apply** | invokes the function and allows you to pass in arguments as an array| Call is for comma (separated list), `func.apply(this, [arg1, arg2]) `|
| **Bind** | returns a new function(bind方法返回的是一个修改过后的函数)| allowing you to pass in a this array and any number of arguments <br/> bind方法传递给调用函数的参数可以逐个列出，也可以写在数组中|

- apply、call、bind三者都是用来改变函数的this对象的指向的
- apply、call、bind三者第一个参数都是this要指向的对象，也就是想指定的上下文
- apply、call二者而言，作用完全一样，只是接受参数的方式不太一样
- Bind returns a new function. Call and Apply execute the current function immediately
- bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入 bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数，即：bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用   
  
```javascript
var zlw = {
    name: "zlw",
    sayHello: function (age) {
         console.log("hello, i am ", this.name + " " + age " years old");
     }
};
var  xlj = { name: "xlj"};
zlw.sayHello(24);// hello, i am zlw 24 years old
zlw.sayHello.call(xlj, 24);// hello, i am xlj 24 years old
zlw.sayHello.apply(xlj, [24]);// hello, i am xlj 24 years old
//注意：bind方法返回的是一个修改过后的函数, 所以bind后面多了()，表示立刻执行
zlw.sayHello.bind(xlj, 24)(); //hello, i am xlj 24 years old, 
zlw.sayHello.bind(xlj)(24); //hello, i am xlj 24 years old
zlw.sayHello.bind(xlj, [24])(); //hello, i am xlj 24 years old
zlw.sayHello.bind(xlj)([24]); //hello, i am xlj 24 years old
//常用用法1: 数组之间追加
var array1 = [12 , "foo" , {name: "Joe"}, -2458];
var array2 = ["Doe", 555, 100];
array1.push(array2);
console.log(array1);    //(5) [12, "foo", {…}, -2458, Array(3)]
Array.prototype.push.apply(array1, array2); 
console.log(array1);    //(7) [12, "foo", {…}, -2458, "Doe", 555, 100]
//常用用法2: 获取数组中的最大值和最小值
var  numbers = [5, 458 , 120 , -215 ]; 
var maxInNumbers = Math.max.apply(Math, numbers),   //458
    maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458
//常用用法3: 验证是否是数组（前提是toString()方法没有被重写过）
functionisArray(obj){ 
    returnObject.prototype.toString.call(obj) === '[object Array]' ;
}
```

**类（伪）数组使用数组方法**: 将一个类数组转为数组

Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。
但能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样domNodes就可以应用Array下的所有方法了

`var domNodes = Array.prototype.slice.call(document.getElementsByTagName("*"));`

**借用一道面试题** - 定义一个log方法，让它可以代理console.log 方法

```javascript
//传统方法
function log(msg)　{ console.log(msg); }
log(1);    //1
log(1,2);    //1
// 使用 apply或call，注意这里传入多少个参数是不确定的，所以使用apply是最好的
function log(){
  console.log.apply(console, arguments);
};
log(1);    //1
log(1,2);    //1 2
//advance:  每一个 log 消息添加一个”(app)”的前辍
function log(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift('(app)');      //unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度
  console.log.apply(console, args);
};
```

**另一道面试题** - 每隔一秒在控制台打印 1-5

```Javascript
//传统方法: 自执行函数表达式 (function(args){..})(args), 或 !function(args){..}(args)
for(var i=0; i<5;i++){
  (function(i){
    setTimeout(function() {
      console.log(i);
    }, i*1000);
  })(i);
}
//ES6
for(let i=0; i<5;i++){
    setTimeout(function() {
      console.log(i);
    }, i*1000);
}
//bind
for(var i=0; i<5;i++){setTimeout(console.log.bind(console, i), i * 1000);}
```

**bind**

`fun.bind(thisArg[, arg1[, arg2[, ...]]])`

- thisArg:        当绑定函数被调用时，该参数会作为原函数运行时的this指向。当使用new操作符调用绑定函数时，该参数无效
- arg1, arg2, …: （可选）当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数

1) bind 用法简单示例

```javascript
// 正常情况下使用变量保存 this 值
var foo = {
	bar : 1,
	eventBind: function(){
		var _this = this ;
		$('.someClass').on('click',function(event) {
			/* Act on the event */
			console.log(_this.bar);		//1
		});
	}
}
// 使用 bind 进行函数绑定
var foo = {
	bar : 1,
	eventBind: function(){
		$('.someClass').on('click',function(event) {
			/* Act on the event */
			console.log(this.bar);		//1
		}.bind(this));
	}
}
var foo = { x: 3 }
var bar = function(){ console.log(this.x); }
bar(); // undefined
var func = bar.bind(foo);
func(); // 3
```

2) bind适用场合

- 配合setTimeout/setInterval:  setTimeout/setInterval的this指向全局window，可以用 bind，显式地把this绑定到回调函数以便继续使用该对象

```Javascript
var canvas = {
  render: function() {
    this.update();
    this.draw();
  },
  update: function() {
    // ...
  },
  draw: function() {
    // ...
  }
};
window.setInterval(canvas.render, 1000 / 60);               //这里render方法中的this其实被指向了window
window.setInterval(canvas.render.bind(canvas), 1000 / 60);  //用 bind，显式地把this绑定到回调函数
```

- 类似的情况还有dom的事件监听，一不小心可能this就被指向了dom元素

```Javascript
this.fn = this.pollTextareas.bind(this);
this.fn();
T.addEvent(window, "scroll", this.fn);
T.addEvent(window, "resize", this.fn);
T.addEvent(doc.body, "touchMove", this.fn);
```

### 如何面试前端工程师：GitHub 很重要


#### 第一部分：Object Prototypes (对象原型)

定义一个方法，传入一个string类型的参数，然后将string的每个字符间加个空格返回

```JavaScript
function spacify(str){
  str.split('').join(' ');
}
spacify('hello world');
//改进： 把这个方法放入String对象上面, 'hello world'.spacify();
String.prototype.spacify = function(){
  return this.split('').join(' ');
}
```

#### 第二部分：参数 arguments

同借用一道面试题、借用另一道面试题

#### 第三部分：上下文

```JavaScript
var User = {
  count: 1,
  getCount: function() {
    return this.count;
  }
};
var func = User.getCount.bind(User);
console.log(func());   //1
//或
User.getCount.bind(User)();   //1
//这个方法对老版本的浏览器不起作用， 考察对apply和call的理解
Function.prototype.bind = Function.prototype.bind || function(context){
  var self = this;
  return function(){
    return self.apply(context, arguments);
  };
}
```

#### 第四部分：弹出窗口（Overlay library）

- 考察点： position中的fixed代替absolute属性，这样即使在滚动的时侯，也能始终让遮罩始盖住整个窗口

- 考察点： 里面的内容居中, 如果内容有固定的宽、高这是可行的。否则就要使用JavaScript

```css
.overlay article {
  position: absolute;
  left: 50%;
  top: 50%;
  margin: -200px 0 0 -200px;
  width: 400px;
  height: 400px;
}
```

- 考察点： 确保当遮罩被点击时要自动关闭

```Javascript
$('.overlay').click(closeOverlay);
//bug - 点击窗口里面的东西也会关闭overlay
$('.overlay').click(function(e){
  if (e.target == e.currentTarget)
    closeOverlay();
});
```

> Reference
- [深入浅出 妙用Javascript中apply、call、bind](http://web.jobbole.com/83642/)
- [如何面试前端工程师：GitHub 很重要](https://segmentfault.com/a/1190000000375138?page=1)

